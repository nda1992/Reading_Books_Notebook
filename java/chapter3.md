# 继承

被继承的类称为超类，进行继承的类被称为子类.<br>

子类不能访问超类中被声明为私有的成员.

当指向子类对象的引用赋值给超类的引用变量时，只能访问子类对象的那些在超类中定义的部分.

*super关键字*

super关键字的两种用法：1)用于调用超类的构造函数；2)访问超类中被子类的某个成员隐藏的成员.<br>

**super必须总是构造函数中执行的第一条语句**<br>

可以使用超类变量引用继承自超类的任何对象.(Box类的构造函数可以传递BoxWeight对象).<br>

当子类调用super()时，会调用直接超类的构造函数，因此，super()总是引用调用类的直接超类.

使用super调用超类的方法(变量):

```java
super.var;
super.method();
```

可以使用super访问被子类隐藏的超类中的变量或方法.<br>

在子类中调用被重写的方法时，总是调用子类定义的版本，由超类定义的版本将会被隐藏.而如果希望调用超类中的方法，可以使用super.method()<br>

*java的动态方法调用*<br>

当通过超类引用调用重写的方法时，java根据在调用时所引用对象的类型来判定代用哪个版本的方法.

**抽象类**

抽象方法不提供方法体.子类需要自己去实现.任何包含一个或多个抽象方法的类都必须声明为抽象类.<br>

**不能使用new运算符直接实例化抽象类**、不能声明抽象的构造函数，也不能声明抽象的静态方法.而抽象类的所有子类，要么实现超类中的所有抽象方法，要么自己也声明为抽象的.<br>

*在继承中使用final*

**使用final声明的方法可以防止重写**

**使用final可以阻止继承**

*Object类*

| 方法                              | 用途                                     |
| --------------------------------- | ---------------------------------------- |
| Object clone()                    | 创建一个和将要复制的对象完全相同的新对象 |
| **boolean equals(Object object)** | 判定一个对象是否和另外一个对象相等       |
| void finalize()                   | 在回收不再使用的对象之前调用             |
| **Class<?> getClass()**           | 在运行时获取对象所属的类                 |
| int hashCode()                    | 返回与调用对象相关联的散列值             |
| **void notify()**                 | 恢复执行在调用对象上等待的某个线程       |
| void notifyAll()                  | 恢复执行在调用对象上等待的所有线程       |
| String toString()                 | 返回对象的字符串                         |















