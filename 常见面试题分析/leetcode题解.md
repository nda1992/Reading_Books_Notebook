# leetcode题解



> 主要是参考了[leetcode](https://leetcode-cn.com/problemset/all/)上的题目以及分享者分享的解答方法.该记录中的所有解题方法都归[leetcode](https://leetcode-cn.com/problemset/all/)所有.
>
> 这里仅仅记录了题解，有些有代码实现，有些没有代码实现.
>
> 目录参考了leetcode上的目录分类方式.

## 数组

### 两数之和

```
使用空间换时间的方式，使用一个HashMap存储元素和对应索引的映射.
过程：
1.遍历一次数组，建立HashMap映射关系；
2.然后再遍历一遍，开始查找，找到对应记录的index即可
```

### 寻找两个有序数组的中位数

```
1.暴力法：
1）如果两个数组中有一个为空，则可以再判断这个不为空的数组的元素是奇数个数还是偶数个数，从而得到中位数
2）如果两个数组都不为空，接着考虑采用归并的思想，将两个数组归并，这样得到一个合并后的数组，然后再求这个合并后的数组的中位数
```

### 盛最多水的容器

```
采用两个指针分别指向数组的左右两端.因为水的容量只受到长度最小的那条边的限制，因此，只需遍历一次数组，并使用一个maxArea来维持水容量的最大值；
最后如果左指针的纵坐标小于有指针的横坐标，则较小者移动向前移动一个位置，反之，则移动另外一个.
因为横纵坐标都会影响到最终的最大容量.
```

### 三数之和

```

```

### 最接近的三数之和

使用一种$O(n^2)$的算法

```
1.先对数组进行排序；这样可以时间复杂度
2.先令res=nums[0]+nums[1]+nums[2]，然后从i=0开始遍历数组，
并将左边指针start=i+1，右边指针end=length-1，计算临时变量sum=nums[i]+nums[start]+nums[end]
3.开始判断target与sum的大小
	1)如果target-sum<target-res，就更新res
	2）如果sum>target,继续向左边寻找较小的sum
	3）返回向右边寻找
	4）如果相等，即距离为0，则返回res
```

### 删除排序数组中的重复项

使用快慢指针法：

```
慢指针：slow
快指针：fast
如果slow与fast索引对应的值相等，则fast++；
否则，将fast存储到++slow中
这样直到fast到达数组的末尾，slow+1的大小就是不相同元素的个数，数组就是前slow个就是不同的元素.
```









### 





## 动态规划

### 最小路径和

问题：给定一个包含非负整数的 *m* x *n* 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小.

Note：每次只能向下或者向右移动一步

```

```

### 正则表达式匹配

问题：给定一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配

> ```
> '.' 匹配任意单个字符
> '*' 匹配零个或多个前面的那一个元素
> ```

### 最大子序和

给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和.

> ```
> 输入: [-2,1,-3,4,-1,2,1,-5,4],
> 输出: 6
> 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
> ```

```
采用动态规划的思想：
1.定义cur=nums[0],sum=0
2.从1～length遍历数组，如果sum>0,则说明当前元素能提高sum，所以加入到sum中
3.如果sum<=0，则说明当前元素不能提高sum，则需要将当前元素更新为sum
4.每次比较cur和sum的大小，将最大值置为cur，最后返回cur
```



## 数字

### 数字1的个数

给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数

> ```
> 输入: 13
> 输出: 6 
> 解释: 数字 1 出现在以下数字中: 1, 10, 11, 12, 13 
> ```

使用的公式：
$$
min(max((n mod (i*10))-i+1,0),i)
$$
其中，$i$为数字$n$的位数.

```java
public static int Solution(int n){
        if (n==0)
            return 0;
        int count = 0;
        for (long i=1;i<=n;i*=10){		//从1~n，每次遍历i就扩大10倍
            long div = i*10;
            count+=(n/div)*i+Math.min(Math.max(n%div-i+1,0L),i);		//(n/div)*i表示(div)位上表示1的个数
            //Math.min(Math.max(n%div-i+1,0L),i)表示需要额外数的(div)位上1的个数
        }
        return count;
    }
```



## 字符串

### 字符串相乘

采用竖向乘法的思想：

将字符串$num1$中的每一位和字符串$num2$相乘.



### 字母异位词分组

给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串

> 输入: ["eat", "tea", "tan", "ate", "nat", "bat"],
> 输出:
> [
>   ["ate","eat","tea"],
>   ["nat","tan"],
>   ["bat"]
> ]

采用hash表的思想：

建立一个HashMap用于存储异位字符串的映射.

遍历String数组中的每个字符串.并对字符串进行排序.

hash表中是否已经含有异位字符串，如果含有，则直接将该字符串加入到相同的异位字符串的key中，否则，新建一个key，并将该字符串加入到其中.

























