# leetcode题解



> 主要是参考了[leetcode](https://leetcode-cn.com/problemset/all/)上的题目以及分享者分享的解答方法.该记录中的所有解题方法都归[leetcode](https://leetcode-cn.com/problemset/all/)所有.
>
> 这里仅仅记录了题解，有些有代码实现，有些没有代码实现.
>
> 目录参考了leetcode上的目录分类方式.

## 数组

### 两数之和

```
使用空间换时间的方式，使用一个HashMap存储元素和对应索引的映射.
过程：
1.遍历一次数组，建立HashMap映射关系；
2.然后再遍历一遍，开始查找，找到对应记录的index即可
```

### 寻找两个有序数组的中位数

```
1.暴力法：
1）如果两个数组中有一个为空，则可以再判断这个不为空的数组的元素是奇数个数还是偶数个数，从而得到中位数
2）如果两个数组都不为空，接着考虑采用归并的思想，将两个数组归并，这样得到一个合并后的数组，然后再求这个合并后的数组的中位数
```

### 盛最多水的容器

```
采用两个指针分别指向数组的左右两端.因为水的容量只受到长度最小的那条边的限制，因此，只需遍历一次数组，并使用一个maxArea来维持水容量的最大值；
最后如果左指针的纵坐标小于有指针的横坐标，则较小者移动向前移动一个位置，反之，则移动另外一个.
因为横纵坐标都会影响到最终的最大容量.
```

### 三数之和

```

```

### 最接近的三数之和

使用一种$O(n^2)$的算法

```
1.先对数组进行排序；这样可以时间复杂度
2.先令res=nums[0]+nums[1]+nums[2]，然后从i=0开始遍历数组，
并将左边指针start=i+1，右边指针end=length-1，计算临时变量sum=nums[i]+nums[start]+nums[end]
3.开始判断target与sum的大小
	1)如果target-sum<target-res，就更新res
	2）如果sum>target,继续向左边寻找较小的sum
	3）返回向右边寻找
	4）如果相等，即距离为0，则返回res
```

### 删除排序数组中的重复项

使用快慢指针法：

```
慢指针：slow
快指针：fast
如果slow与fast索引对应的值相等，则fast++；
否则，将fast存储到++slow中
这样直到fast到达数组的末尾，slow+1的大小就是不相同元素的个数，数组就是前slow个就是不同的元素.
```















## 动态规划

### 最小路径和

问题：给定一个包含非负整数的 *m* x *n* 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小.

Note：每次只能向下或者向右移动一步

```

```

### 正则表达式匹配

问题：给定一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配

> ```
> '.' 匹配任意单个字符
> '*' 匹配零个或多个前面的那一个元素
> ```







