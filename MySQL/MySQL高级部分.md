# MySQL高级

### MySQL主从复制的原理







### MySQL的SQL语句如何优化？

```
1、在表中建立索引，需要优先考虑where和group by用到的字段

2、尽量不要使用SELECT * ，返回无用的字段对拖累查询的速度

3、尽量不要使用in 和not in，这样导致数据库放弃索引，而进行全表扫描

4、尽量避免使用or，会导致数据库引擎放弃索引，进行全表扫描

5、尽量避免使用开头模糊查询，会导致数据库引擎放弃索引进行全表扫描
```





### InnoDB和MyISAM的区别有哪些

```
1、InnoDB支持事务，MyISAM不支持

2、InnoDB支持行级锁和表级锁，MyISAM只支持表级锁

3、InnoDB支持MVCC，MyISAM不支持

4、InnoDB在5.7之前不支持全文索引，MyISAM支持

5、InnoDB支持外键，MyISAM不支持

6、InnoDB使用的是聚集索引（叶子节点保存数据本身），MyISAM使用的是非聚集索引（叶子节点保存的是数据索引）

```



### MySQL如何做到优化

```
1、硬件优化
CPU、内存、磁盘、网卡

2、软件优化
操作系用优化

3、my.cnf配置参数优化
```



### MySQL的高可用方案有哪些

- 主从复制+读写分离

```
优点：成本低、架构简单、容易实施、维护方便

缺点：master出现故障后，不能自动转移到slave上，需要人工干预
```

- MySQL Cluster

```-
优点：安全性高、稳定性高，可以在线增加节点

缺点：架构复杂、至少三个节点，不支持外键、管理复杂
```

- keepalived+双主复制

```
优点：安全性高、稳定性高、出现故障可以自动切换、保证服务的连续性

缺点：可能会发生脑裂
```

- Heartbeat +DRBD + MySQL

```
优点：安全性、稳定性、出现故障系统将自动切换，保证服务的连续性

缺点：只能用一台服务器提供服务，成本高，可能发生脑裂
```



###  **网站打开慢，请给出排查方法，如是数据库慢导致，如何排查并解决，请分析并举例？**

```
1、检查系统是否负载过高

2、登录MySQL查看有哪些sql语句占用时间过长

3、用explain查看消耗时间过长的sql语句是否使用了索引

4、对sql优化，建立索引
```



### MySQL索引的类型有哪些

```
普通索引：最基本的索引，没有任何限制

唯一索引:与普通索引类似，不同的是，索引列的值必须唯一，但允许有空值

主键索引:它是一种特殊的唯一索引，不允许有空值。一张表只能有一个主键。

组合索引:就是将多个字段建到一个索引里
```



### 数据库表文件

- InnoDB存储引擎中的表文件

InnoDB的表包含两种后缀名的文件，分别为**.frm**和**.ibd**

**.frm**是文件中存储了表结构的信息

**.ibd**是文件中存储了表的数据信息和索引信息

- MyISAM存储引擎中的表文件

MyISAM的表文件有三类：**.frm**、**.MYD**、**.MYI**

**.frm**：存放了表结构信息

**.MYD**：存放了数据信息

**.MYI**：存放了索引信息



### MySQL事务

事务包含了一条或若干条SQL语句，这些语句要么全部成功执行，要么全部失败，这个过程称为事务.

- ACID特性

**原子性（atomicity）**：整个事务要么成功执行，要么全部失败并回滚到最初始的状态

**一致性（consistency）**：数据库从一个一致性状态转移到另一个一致性状态

**隔离性（isolation）**：一个事务在提交之前所做的操作是否为其他事务可见，根据不同的场景有不同的隔离级别

**持久性（durability）**：事务一旦提交，事务所做出的修改将会永久保存到数据库中，及时数据库崩溃。数据也不会丢失



- MySQL的四种隔离级别

*READ-UNCOMMITTED*：读未提交

*READ-COMMITTED*：读已提交

```

```



*REPEATABLE-READ*：可重复读（MySQL默认）

```
假设有两个事务（A和B），如果A中对数据的更新已经提交，在B中没有提交之前，B看到的数据都是相同的，不管A是否已经提交，对B来说数据都没有改变，这条数据可以被B重复读取到，这种隔离级别称为可重复读（事务B采用了一致性非锁定读的策略，B读取的数据相当于一个快照（快照：指的是该行所对应的之前的版本的数据，即历史数据，同时，一行可能不止存在一个快照数据））

但这种情况下会出现幻读（当一个事务插入新的记录时，在另一个事务中可以看到刚插入的记录）

```

*SERIALIZABLE*：串行化

```
两个事务A和B，当A事务设置了串行化时，B进行操作时会被阻塞，此时它编写等待A提交事务后，才可以进行操作。
串行化使得数据库失去了并发能力，在实际中很少使用
```



### MySQL日志分析

#### 二进制日志（binlog）

二进制日志称为binlog，记录了数据库所有修改情况（update），binlog的作用是**用于时间点的恢复以及主从复制结构**.

```
时间点恢复的举例说明：

如果我们每天需要在凌晨5点对数据库进行备份，那么如果某一天的凌晨5点之前数据库发生了故障，导致我们还没来得及备份，而如果我们希望取恢复数据，但是也仅仅能恢复到昨天凌晨5点的数据，之后到故障前的所有数据都没办法恢复，此时需要使用binlog，它记录了崩溃前数据的变化情况，我们使用binlog（它记录了所有的更改操作的sql，我们只需要对该日志进行“重放”即可实现恢复）可以恢复到发生故障前的情况.
```

- binlog记录的三种形式

```
可以使用binlog_format变量设置不同的模式

statement：对更新操作的行进行记录，但是不如row详细，优点是binlog数据量较小、IO压力小，性能较高，但不能保证恢复操作和记录时的完全一致

row：记录对数据库做出的修改的语句所影响到的数据行，以及这些行的修改，如更新1000条记录时，update语句对这1000条记录所影响到和行都记录到binlog中，并且还会记录这些行是怎样被修改的。它的好处是能够完全还原或复制日志所做的操作，缺点是记录日志的数量量较大，IO压力也变大，性能消耗大（但是在实际生产中为了保险起见，还是需要使用row）

mixed：混合了statement和row两种模式
```

- 深入理解binlog

binlog是二进制类型的文件，它有**事件（event）**和**位置（position）**的概念；对于每条记录，就对应一个**事件**。binlog就是一个字节序列，所以每个事件都有对应的开始位置结束位置。

一些常用参数

*bin_log*：控制是否开启二进制日志，这是一个只读变量，不能在当前的会话中进行修改，而需要通过修改my.cnf（开启：ON，关闭：OFF）。不要在my.cnf中直接设置ON或OFF，因为在my.cnf中设置了log_bin对应的值（该名称就是保存binlog对应的文件名的前缀），就表示已经开启了日志功能，如果不设置，就表示没有开启.

*sql_log_bin*：此变量用于标识当前会话中的操作是否被被记录二进制日志.

*max_binlog_size*：设置单个binlog文件的最大值

*sync_binlog*：设置经过多少次事务后binlog刷新到磁盘

- 常用操作命令

```mysql
-- 查询binlog是否已经开启
show variables like "%log_bin";

+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| log_bin       | ON    |
| sql_log_bin   | ON    |
+---------------+-------+

-- 这时可以修改my.cnf中的log_bin配置项

-- 查看binlog列表
show binary logs;

+------------------+-----------+
| Log_name         | File_size |
+------------------+-----------+
| mysql-bin.000188 |       201 |
| mysql-bin.000189 |       201 |
| mysql-bin.000190 |       201 |
| mysql-bin.000191 |       201 |
| mysql-bin.000192 |       201 |
| mysql-bin.000193 |       201 |
| mysql-bin.000194 |       201 |
| mysql-bin.000195 |       201 |
| mysql-bin.000196 |       201 |
| mysql-bin.000197 |       201 |
| mysql-bin.000198 |       177 |
| mysql-bin.000199 |       154 |
| mysql-bin.000200 |       177 |
| mysql-bin.000201 |       154 |
+------------------+-----------+


-- 查看binlog的日志模式
show variables like "%binlog_format%";

+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| binlog_format | ROW   |
+---------------+-------+
1 row in set (0.00 sec)


-- 查看二进制文件内容
show binlog events in 'mysql-bin.000201';

+------------------+-----+----------------+-----------+-------------+--------------------------------------------------------+
| Log_name         | Pos | Event_type     | Server_id | End_log_pos | Info                                                   |
+------------------+-----+----------------+-----------+-------------+--------------------------------------------------------+
| mysql-bin.000201 |   4 | Format_desc    |        10 |         123 | Server ver: 5.7.29-0ubuntu0.18.04.1-log, Binlog ver: 4 |
| mysql-bin.000201 | 123 | Previous_gtids |        10 |         154 |                                                        |
+------------------+-----+----------------+-----------+-------------+--------------------------------------------------------+

-- 从指定位置查看二进制日志
show binlog events in 'mysql-bin.000188' from 154;

+------------------+-----+------------+-----------+-------------+------------------------+
| Log_name         | Pos | Event_type | Server_id | End_log_pos | Info                   |
+------------------+-----+------------+-----------+-------------+------------------------+
| mysql-bin.000188 | 154 | Rotate     |        10 |         201 | mysql-bin.000189;pos=4 |
+------------------+-----+------------+-----------+-------------+------------------------+

-- 查看当前使用的二进制日志以及二进制日志已经记录的位置
show master status;
+------------------+----------+--------------+------------------+-------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+------------------+----------+--------------+------------------+-------------------+
| mysql-bin.000201 |      154 |              |                  |                   |
+------------------+----------+--------------+------------------+-------------------+
1 row in set (0.00 sec)


-- 滚动二进制日志（当单个binlog达到了指定的大小就会自动滚动，也可以使用flush logs进行手动进行日志滚动）
flush logs;
```

```bash
- 在bash中查看二进制日志
mysqlbinlog --no-defaults mysql-bin.000188
```

#### redo log

> redo log和undo log都属于事务日志

redo log记录的是一个事务的所有操作，它只是占时记录，并没有提交。使用redo log可以实现原子性操作。

redo log分为：redo log buffer（重做日志缓冲）和redo log file（重做日志文件）

redo log是物理日志，因为redo log中记录的是数据库对页的操作，而不是逻辑上的增删改查，重做日志具有幂等性



#### undo log

undo log可以理解成数据被修改前的备份





### MySQL主从复制

#### 概念

用于建立和主数据库完全相同的数据库环境，称为从数据库，主数据库提供实时的服务.

#### 作用

- 做数据的热备份，作为后备数据库，主库出现故障后，可以切换到从库继续提供服务，避免了数据丢失
- 架构扩展，随着业务的不断增大，单机无法满足，此时需要做多库存储，降低IO访问频率，提高单个机器的IO性能
- 读写分离，使得数据库能支撑更大的并发

#### 原理

**使用数据库中的binlog日志进行数据即可**

目的是将主库中的binlog复制到从库中，并在从库中执行一遍binlog，即可完成数据的复制.















































